<!DOCTYPE html>
<html dir="ltr" lang="en-US">
	<head>
		<title>copper.js Tests</title>
		<link href="../ext/qunit.css" rel="stylesheet" type="text/css" />

		<script src="../ext/jquery-1.7.1.min.js" type="text/javascript"></script>
		<script src="../ext/underscore-1.2.2.min.js" type="text/javascript"></script>
		<script src="../ext/qunit.js" type="text/javascript"></script>
		<script src="../src/copper.js" type="text/javascript"></script>
	</head>
	<body>
		<h1 id="qunit-header">copper.js Tests</h1>
		<h2 id="qunit-banner"></h2>
		<div id="qunit-testrunner-toolbar"></div>
		<h2 id="qunit-userAgent"></h2>
		<ol id="qunit-tests"></ol>
		<div id="qunit-fixture">
			<a id="helloAnchor" href="#" />
			<button id="helloButton" />
			<input id="helloInputSubmit" type="submit" />
			<input id="helloInputButton" type="button" />
			<input id="helloInputReset" type="reset" />
			<p id="dynamicContent"></p>
			<p id="dynamicClass"></p>
			<input id="dynamicInput" type="text" />
			<input name="namedInput" type="text" />
			<div id="subView"></div>
			<div id="subView2">
				<input id="compoundScopedInput" type="text" />
			</div>
			<div id="modalElement"></div>
			<input name="namedModalInput" type="text"></div>
		</div>
	</body>
	<script>
		module('Observable');

		test('Given initial value, when constructed, accessor yields initial value.', function () {
			// Arrange
			var value = 'SomethingSomething',
				subject;

			// Act
			subject = new Cu.Observable(value);

			// Assert
			equal(subject.val(), value);
		});

		test('Given initial value, when new value set, accessor yields new value.', function () {
			// Arrange
			var replacementValue = 'SomethingNew',
				subject = new Cu.Observable('SomethingSomething');

			// Act
			subject.val(replacementValue);

			// Assert
			equal(subject.val(), replacementValue);
		});

		test('Given subscription, when new value set, handler called with new value.', function () {
			// Arrange
			var replacementValue = 'SomethingNew',
				subject = new Cu.Observable('SomethingSomething'),
				storedByHandler = undefined;

			subject.subscribe(function (newValue) {
				storedByHandler = newValue;
			});

			// Act
			subject.val(replacementValue);

			// Assert
			equal(storedByHandler, replacementValue);
		});

		test('Given multiple subscriptions, when new value set, handlers all called with new value.', function () {
			// Arrange
			var replacementValue = 'SomethingNew',
				subject = new Cu.Observable('SomethingSomething'),
				storedByHandlers = [],
				handlerCount = 7;

			_.range(0, handlerCount).forEach(function () {
				subject.subscribe(function (newValue) {
					storedByHandlers.push(newValue);
				});
			});

			// Act
			subject.val(replacementValue);

			// Assert
			ok(storedByHandlers.length == handlerCount
				&& _(storedByHandlers).without(replacementValue).length == 0);
		});

		test('Given multiple subscriptions, and given a handler is unsubscribed, when new value set, handlers all called with new value.', function () {
			// Arrange
			var replacementValue = 'SomethingNew',
				subject = new Cu.Observable('SomethingSomething'),
				handler1Called = false,
				handler1 = function () { handler1Called = true },
				handler2Called = false,
				handler2 = function () { handler2Called = true }

			subject.subscribe(handler1);
			subject.subscribe(handler2);

			// Act
			subject.unsubscribe(handler1);
			subject.val(replacementValue);

			// Assert
			ok(handler2Called && !handler1Called);
		});

		test('Given multiple subscriptions, and given release was called, when new value set, handlers all called with new value.', function () {
			// Arrange
			var replacementValue = 'SomethingNew',
				subject = new Cu.Observable('SomethingSomething'),
				handler1Called = false,
				handler1 = function () { handler1Called = true },
				handler2Called = false,
				handler2 = function () { handler2Called = true }

			subject.subscribe(handler1);
			subject.subscribe(handler2);

			// Act
			subject.release();
			subject.val(replacementValue);

			// Assert
			ok(!handler1Called && !handler2Called);
		});
		
		module('Computed');
		
		var givenObservableWithInitialValue = function(initialValue, continueTest) {
			continueTest(new Cu.Observable(initialValue));
		};
		
		test('Given a simple Observable, and given an observable dependent on it, when simple observable value changes, handlers of dependent observable are called with dependent value.', function () {
			
			givenObservableWithInitialValue('SomethingSomething', function (simpleObservable) {
				var replacementValue = 'SomethingNew',
					transformation = 'SomethingExtra',
					storedByHandler = undefined,
					dependent;
					
				dependent = simpleObservable.as(function (newValue) {
					return newValue + transformation;
				});

				dependent.subscribe(function (newValue) {
					storedByHandler = newValue;
				});
			
				simpleObservable.val(replacementValue);

				equal(storedByHandler, replacementValue + transformation);
			});
		});
		
		test('Given a simple Observable, and given an conditional observable dependent on it, when simple observable value change matches condition, handlers of dependent observable are called with new value.', function () {
			
			givenObservableWithInitialValue('SomethingSomething', function (simpleObservable) {
				var replacementValue = 'SomethingNew',
					storedByHandler = undefined,
					dependent;
					
				dependent = simpleObservable.when(function (newValue) {
					return newValue.length > 0;
				});

				dependent.subscribe(function (newValue) {
					storedByHandler = newValue;
				});
			
				simpleObservable.val(replacementValue);

				equal(storedByHandler, replacementValue);
			});
		});
		
		test('Given a simple Observable, and given an conditional observable dependent on it, when simple observable value change does not match condition, handlers of dependent observable are not called.', function () {
			
			givenObservableWithInitialValue('SomethingSomething', function (simpleObservable) {
				var replacementValue = 'SomethingNew',
					handlerCalled = false,
					dependent;
					
				dependent = simpleObservable.when(function (newValue) {
					return newValue.length == 0;
				});

				dependent.subscribe(function (newValue) {
					handlerCalled = true;
				});
			
				simpleObservable.val(replacementValue);

				ok(!handlerCalled);
			});
		});
		
		test('Given a simple Observable, and given chain dependent on it, when simple observable value change matches conditions, handlers of dependent observable are called with result of chain.', function () {
			
			givenObservableWithInitialValue(5, function (simpleObservable) {
				var replacementValue = 6,
					handlerCalled = false,
					transformation1 = function (newValue) {
						return newValue * 2;
					},
					transformation2 = function (newValue) {
						return newValue * 2;
					},
					storedByHandler = undefined,
					dependent;
					
				dependent = simpleObservable.when(function (newValue) {
					return (newValue.length % 2) != 1;
				}).as(transformation1).when(function (newValue) {
					return newValue > 10;
				}).as(transformation2);

				dependent.subscribe(function (newValue) {
					storedByHandler = newValue;
				});
			
				simpleObservable.val(replacementValue);

				equal(storedByHandler, transformation2(transformation2(replacementValue)));
			});
		});
		
		test('Given two simple Observables, and given a Computed dependent on both, when eacg simple observable value is changed, handlers of dependent observable are called with result of transformation.', function () {
			var initialValue1 = 5,
				initialValue2 = 10;

			givenObservableWithInitialValue(initialValue1, function (simpleObservable1) {
				givenObservableWithInitialValue(initialValue2, function (simpleObservable2) {
					var replacementValue1 = 6,
						replacementValue2 = 11,
						storedByHandler = undefined,
						liveTransformation = function () {
							return simpleObservable1.val() + simpleObservable2.val();
						},
						transformation = function (value1, value2) {
							return value1 + value2;
						},
						dependent;

					dependent = new Cu.Computed({
						from: [simpleObservable1, simpleObservable2],
						as: transformation
					});

					dependent.subscribe(function (newValue) {
						storedByHandler = newValue;
					});

					equal(dependent.val(), liveTransformation());

					simpleObservable1.val(replacementValue1);

					equal(storedByHandler, liveTransformation());

					simpleObservable2.val(replacementValue1);

					equal(storedByHandler, liveTransformation());
				});
			});
		});
		
		module('ObservableCollection');

		test('Given no initial value, when constructed, accessor yields empty array.', function () {
			// Arrange
			var subject;

			// Act
			subject = new Cu.ObservableCollection();

			// Assert
			deepEqual(subject.val(), []);
		});

		test('Given initial value, when constructed, accessor yields initial value.', function () {
			// Arrange
			var value = [1, 2, 3],
				subject;

			// Act
			subject = new Cu.ObservableCollection(value);

			// Assert
			equal(subject.val(), value);
		});

		test('Given initial value, when new collection replaced, accessor yields new value.', function () {
			// Arrange
			var replacementValue = ['SomethingNew', 'Something 2', 'Something 3'],
				subject = new Cu.ObservableCollection(['SomethingSomething', 'Wonderwall', 'Splendor']);

			// Act
			subject.val(replacementValue);

			// Assert
			equal(subject.val(), replacementValue);
		});

		test('Given subscription, when new value set, handler called with new value.', function () {
			// Arrange
			var replacementValue = ['SomethingNew', 'Something 2', 'Something 3'],
				subject = new Cu.ObservableCollection(['SomethingSomething', 'Wonderwall', 'Splendor']),
				storedByHandler = undefined;

			subject.subscribe('collectionReplaced', function (newValue) {
				storedByHandler = newValue;
			});

			// Act
			subject.val(replacementValue);

			// Assert
			equal(storedByHandler, replacementValue);
		});
		
		test('Given existing collection, when value added, accessor yields array with value added to end.', function () {
			// Arrange
			var initialValue = ['A', 'B', 'D', 'E'],
				subject = new Cu.ObservableCollection(initialValue),
				valueToAdd = 'C',
				expectedValue;

			expectedValue = initialValue.slice(0);
			expectedValue.push(valueToAdd);
				
			// Act
			subject.add(valueToAdd);

			// Assert
			deepEqual(initialValue, expectedValue);
		});
		
		test('Given subscription, when value added, handler called with new value and index.', function () {
			// Arrange
			var initialValue = ['A', 'B', 'D', 'E'],
				subject = new Cu.ObservableCollection(initialValue),
				valueToAdd = 'C',
				indexToAdd = initialValue.length,
				valueAdded,
				addedIndex;

			subject.subscribe('itemAdded', function (item, index) {
				valueAdded = item;
				addedIndex = index;
			});

			// Act
			subject.add(valueToAdd);

			// Assert
			equal(valueAdded, valueToAdd);
			equal(addedIndex, indexToAdd);
		});
		
		test('Given existing collection, when value added at index, accessor yields array with added value.', function () {
			// Arrange
			var initialValue = ['A', 'B', 'D', 'E'],
				subject = new Cu.ObservableCollection(initialValue),
				valueToAdd = 'C',
				indexToAdd = 2,
				expectedValue;

			expectedValue = initialValue.slice(0);
			expectedValue.splice(indexToAdd, 0, valueToAdd);
				
			// Act
			subject.add(valueToAdd, indexToAdd);

			// Assert
			deepEqual(initialValue, expectedValue);
		});

		test('Given subscription, when value added, handler called with new value and index.', function () {
			// Arrange
			var subject = new Cu.ObservableCollection(['A', 'B', 'D', 'E']),
				valueToAdd = 'C',
				indexToAdd = '2',
				valueAdded,
				addedIndex;

			subject.subscribe('itemAdded', function (item, index) {
				valueAdded = item;
				addedIndex = index;
			});

			// Act
			subject.add(valueToAdd, indexToAdd);

			// Assert
			equal(valueAdded, valueToAdd);
			equal(addedIndex, indexToAdd);
		});
		
		test('Given existing collection, when value removed, accessor yields array with value removed.', function () {
			// Arrange
			var initialValue = ['A', 'C', 'B', 'E', 'D'],
				subject = new Cu.ObservableCollection(initialValue),
				valueToRemove = 'C',
				expectedValue = initialValue;
				
			expectedValue.splice(expectedValue.indexOf(valueToRemove), 1);
				
			// Act
			subject.remove(valueToRemove);

			// Assert
			deepEqual(initialValue, expectedValue);
		});

		test('Given subscription, when value removed, handler called with new value and index.', function () {
			// Arrange
			var initialValue = ['A', 'C', 'B', 'E', 'D'],
				subject = new Cu.ObservableCollection(initialValue),
				valueToRemove = 'C',
				indexToRemove = initialValue.indexOf(valueToRemove),
				valueremoved,
				removedIndex;

			subject.subscribe('itemRemoved', function (item, index) {
				valueremoved = item;
				removedIndex = index;
			});

			// Act
			subject.remove(valueToRemove);

			// Assert
			equal(valueremoved, valueToRemove);
			equal(removedIndex, indexToRemove);
		});
		
		test('Given existing collection, when value removed at index, accessor yields array with value removed.', function () {
			// Arrange
			var initialValue = ['A', 'C', 'B', 'E', 'D'],
				subject = new Cu.ObservableCollection(initialValue),
				indexToRemove = 3;
				expectedValue = initialValue;
				
			expectedValue.splice(indexToRemove, 1);
				
			// Act
			subject.removeAt(indexToRemove);

			// Assert
			deepEqual(initialValue, expectedValue);
		});

		test('Given subscription, when value removed at index, handler called with removed value and index.', function () {
			// Arrange
			var initialValue = ['A', 'C', 'B', 'E', 'D'],
				subject = new Cu.ObservableCollection(initialValue),
				indexToRemove = 4,
				valueToRemove = initialValue[indexToRemove],
				valueRemoved,
				removedIndex;

			subject.subscribe('itemRemoved', function (item, index) {
				valueRemoved = item;
				removedIndex = index;
			});

			// Act
			subject.removeAt(indexToRemove);

			// Assert
			equal(valueRemoved, valueToRemove);
			equal(removedIndex, indexToRemove);
		});
		
		module('SmartEvent');

		test('ctor / Given name / Initializes name property to specified value', function () {
			// Arrange
			var name = 'SecurityBreach',
				subject;

			// Act
			subject = new Cu.SmartEvent(name);

			// Assert
			equal(subject.name, name);
		});

		test('ctor / Initializes handlers property to empty', function () {
			// Arrange
			var subject;

			// Act
			subject = new Cu.SmartEvent();

			// Assert
			deepEqual(subject.handlers, []);
		});

		test('subscribe / Given function / Adds handler to handlers list', function () {
			// Arrange
			var subject = new Cu.SmartEvent(),
				handler = function () { };

			// Act
			subject.subscribe(handler);

			// Assert
			deepEqual(subject.handlers, [handler]);
		});

		test('subscribe / Given function already added / Does not add handler again', function () {
			// Arrange
			var subject = new Cu.SmartEvent(),
				handler1 = function () { },
				handler2 = function () { };

			subject.subscribe(handler1);
			subject.subscribe(handler2);

			// Act
			subject.subscribe(handler1);

			// Assert
			deepEqual(subject.handlers, [handler1, handler2]);
		});

		test('subscribe / Given a non-function value / Does nothing', function () {
			// Arrange
			var subject = new Cu.SmartEvent();

			// Act
			subject.subscribe({ something: 'not a function' });

			// Assert
			deepEqual(subject.handlers, []);
		});

		test('unsubscribe / Given a function already added / Removes handler', function () {
			// Arrange
			var subject = new Cu.SmartEvent(),
				handler1 = function () { },
				handler2 = function () { };

			subject.subscribe(handler1);
			subject.subscribe(handler2);

			// Act
			subject.unsubscribe(handler2);

			// Assert
			deepEqual(subject.handlers, [handler1]);
		});

		test('unsubscribe / Given a function not yet added / Does nothing', function () {
			// Arrange
			var subject = new Cu.SmartEvent(),
				handler1 = function () { },
				handler2 = function () { };

			subject.subscribe(handler1);
			
			// Act
			subject.unsubscribe(handler2);

			// Assert
			deepEqual(subject.handlers, [handler1]);
		});

		test('unsubscribe / Given a non-function value / Does nothing', function () {
			// Arrange
			var subject = new Cu.SmartEvent(),
				handler = function () { };

			subject.subscribe(handler);

			// Act
			subject.unsubscribe({ something: 'not a function' });

			// Assert
			deepEqual(subject.handlers, [handler]);
		});

		test('raise / Calls each subscribed function', function () {
			// Arrange
			var subject = new Cu.SmartEvent(),
				handler1Called = false,
				handler1 = function () { handler1Called = true },
				handler2Called = false,
				handler2 = function () { handler2Called = true },
				handler3Called = false,
				handler3 = function () { handler3Called = true };

			subject.subscribe(handler1);
			subject.subscribe(handler2);
			subject.subscribe(handler3);

			// Act
			subject.raise();

			// Assert
			ok(_([handler1Called, handler2Called, handler3Called]).all(function (item) { return item; }));
		});
		
		module('Wire');

		test('Given a view with no bindModel method / Wire creates one.', function () {
			// Arrange
			var view = {},
				model = { something: 'something' };

			Cu.Wire({
				model: {},
				view: view
			});
			
			// Act
			view.bindModel(model);

			// Assert
			equal(view._model, model);
		});
		
		givenModelWithFunctionProperty = function (propertyName, propertyFunction, continueTest) {
			var model = {};
			model[propertyName] = propertyFunction;
			continueTest(model);
		}

		test('Given a model with a function property with name the same as ID of an anchor in the HTML / When anchor clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				propertyName = 'helloAnchor',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				Cu.Wire({ model: model });

				// Act
				$('#' + propertyName).click();
			});

			// Assert
			ok(called);
		});
		
		var handlerNameFromClickable = function (clickableName) {
			return clickableName + '_Clicked';
		};
		
		var handlerNameFromInput = function (inputName) {
			return inputName + '_ViewChanged';
		};
		
		var assertInputBindingExists = function (view, elementSelector, handlerName) {
			bindings = _(view._inputBindings).filter(function (binding) {
				return (binding.source().is(elementSelector)
					&& binding.target() == handlerName);
			});
			
			ok(bindings.length == 1);
		};
		
		test('Given a model with a function property with name the same as ID of an anchor in the HTML / Input binding is created ', function () {
			var called = false,
				propertyName = 'helloAnchor',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				var view = {},
					bindings = [];
				
				Cu.Wire({
					view: view,
					model: model
				});
				
				assertInputBindingExists(view, '#' + propertyName, handlerNameFromClickable(propertyName));
			});
		});
		
		test('Given a model with a function property /  Given a view selector hash entry with name of function property and matching an anchor in the HTML / When anchor clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				propertyName = 'overreaction',
				id = 'helloAnchor',
				propertyFunction = function () { called = true; },
				selectors = {};
				
			selectors[propertyName] = '#' + id;

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				Cu.Wire({
					model: model,
					view: {
						selectorFor: selectors
					}
				});

				// Act
				$('#' + id).click();
			});

			// Assert
			ok(called);
		});
		
		test('Given a model with a function property /  Given a view selector hash entry with name of function property and matching an anchor in the HTML / Input binding is created ', function () {
			var called = false,
				propertyName = 'overreaction',
				id = 'helloAnchor',
				propertyFunction = function () { called = true; },
				selectors = {};
				
			selectors[propertyName] = '#' + id;

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				var view = {
					selectorFor: selectors
				};
				
				Cu.Wire({
					model: model,
					view: view
				});

				assertInputBindingExists(view, '#' + id, handlerNameFromClickable(propertyName));
			});
		});

		test('Given a model with a function property with name the same ID as a button in the HTML / When button clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				propertyName = 'helloButton',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				Cu.Wire({ model: model });

				// Act
				$('#' + propertyName).click();
			});

			// Assert
			ok(called);
		});
		
		test('Given a model with a function property with name the same ID as a button in the HTML / Input binding is created ', function () {
			var called = false,
				propertyName = 'helloButton',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				var view = {};
				
				Cu.Wire({
					model: model,
					view: view
				});

				assertInputBindingExists(view, '#' + propertyName, handlerNameFromClickable(propertyName));
			});
		});

		test('Given a model with a function property with name the same ID as a submit input in the HTML / When submit input clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				propertyName = 'helloInputSubmit',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				Cu.Wire({ model: model });

				// Act
				$('#' + propertyName).click();
			});

			// Assert
			ok(called);
		});
		
		test('Given a model with a function property with name the same ID as a submit input in the HTML / Input binding is created ', function () {
			var called = false,
				propertyName = 'helloInputSubmit',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				var view = {};
				
				Cu.Wire({
					view: view,
					model: model
				});

				assertInputBindingExists(view, '#' + propertyName, handlerNameFromClickable(propertyName));
			});
		});

		test('Given a model with a function property with name the same ID as a button input in the HTML / When button input clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				propertyName = 'helloInputButton',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				Cu.Wire({ model: model });

				// Act
				$('#' + propertyName).click();
			});

			// Assert
			ok(called);
		});
		
		test('Given a model with a function property with name the same ID as a button input in the HTML / Input binding is created ', function () {
			var called = false,
				propertyName = 'helloInputButton',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				var view = {};
				
				Cu.Wire({
					view: view,
					model: model
				});

				assertInputBindingExists(view, '#' + propertyName, handlerNameFromClickable(propertyName));
			});
		});

		test('Given a model with a function property with name the same ID as a reset input in the HTML / When reset input clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				propertyName = 'helloInputReset',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				Cu.Wire({ model: model });

				// Act
				$('#' + propertyName).click();
			});

			// Assert
			ok(called);
		});
		
		test('Given a model with a function property with name the same ID as a reset input in the HTML / When reset input clicked / Input binding is created ', function () {
			var called = false,
				propertyName = 'helloInputReset',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				var view = {};
				
				Cu.Wire({
					view: view,
					model: model
				});

				assertInputBindingExists(view, '#' + propertyName, handlerNameFromClickable(propertyName));
			});
		});

		test('Given a model with a function property with name "Clicked" and a view with a clickable scope element / When element clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				docScope = $('#helloAnchor'),
				propertyName = 'Click',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				Cu.Wire({
					view: {
						$documentScope: docScope
					},
					model: model });

				// Act
				docScope.click();
			});

			// Assert
			ok(called);
		});
		
		test('Given a model with a function property with name "Clicked" and a view with a clickable scope element / Input binding is created ', function () {
			var called = false,
				scopeSelector = '#helloAnchor',
				docScope = $(scopeSelector),
				propertyName = 'Click',
				handlerName = 'Clicked'
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				var view = {
					$documentScope: docScope
				};
				
				Cu.Wire({
					view: view,
					model: model });

				assertInputBindingExists(view, scopeSelector, handlerName);
			});
		});

		test('Given a model with a function property with name not found in HTML / Constructor does not throw', function () {
			expect(1);

			// Arrange
			var propertyName = 'iDoNotExist';

			givenModelWithFunctionProperty(propertyName, function () { }, function (model) {
				Cu.Wire({ model: model });

				// Assert
				ok(true);
			});
		});

		var givenModelWithObservableProperty = function (propertyName, initialValue, continueTest) {
			var model = {};
			model[propertyName] = new Cu.Observable(initialValue);
			continueTest(model);
		};

		var givenTagWithIdContainsText = function (id, content, continueTest) {
			$('#' + id).html(content);
			continueTest();
		};

		var givenInputWithIdHasValue = function (id, value, continueTest) {
			$('#' + id).val(value);
			continueTest();
		};
		
		var givenInputWithNameHasValue = function (id, value, continueTest) {
			var selector = 'input[name="' + id + '"]';
			$(selector).val(value);
			continueTest(selector);
		};

		test('Given a model with an Observable property with name the same ID as an element in the HTML / When observable changes / HTML element content is changed to match observable value', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'dynamicContent',
				initialValue = 'blah',
				oldContent = 'Something unremarkable',
				newContent = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenTagWithIdContainsText(propertyName, oldContent, function () {
					Cu.Wire({ model: model });

					// Act
					model[propertyName].val(newContent);

					// Assert
					equal($('#' + propertyName).html(), newContent);
				});
			});
		});
		
		var assertModelBindingExists = function (view, modelPropertyName, handlerName) {
			bindings = _(view._modelBindings).filter(function (binding) {
				return (binding.source() == modelPropertyName
					&& binding.target() == handlerName);
			});
			
			ok(bindings.length == 1);
		};
		
		var givenBlankViewBoundToModel = function(model, continueTest) {
			var view = {};
			
			Cu.Wire({
				view: view,
				model: model
			});
			
			continueTest(view);
		};
		
		test('Given a model with an Observable property with name the same ID as an input element in the HTML / Input binding is created ', function () {

			var called = false,
				propertyName = 'dynamicInput',
				initialValue = 'blah',
				oldContent = 'Something unremarkable',
				newContent = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenTagWithIdContainsText(propertyName, oldContent, function () {
					givenBlankViewBoundToModel(model, function (view) {
						assertInputBindingExists(view, '#' + propertyName, handlerNameFromInput(propertyName));
					});
				});
			});
		});
		
		var modelChangeHandlerName = function (propertyName) {
			return propertyName + '_ModelChanged';
		};
		
		test('Given a model with an Observable property with name the same ID as an element in the HTML / Model binding is created ', function () {

			var called = false,
				propertyName = 'dynamicContent',
				initialValue = 'blah',
				oldContent = 'Something unremarkable',
				newContent = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenTagWithIdContainsText(propertyName, oldContent, function () {
					givenBlankViewBoundToModel(model, function (view) {
						assertModelBindingExists(view, propertyName, modelChangeHandlerName(propertyName));
					});
				});
			});
		});


		var givenElementWithClass = function ($element, extraClass, continueTest) {
			if (!$element.hasClass(extraClass)) {
				$element.addClass(extraClass);
			}
			
			continueTest();
		};
		
		test('Given a model with an Observable property with name in the format "X_Is_Y" / Given classless HTML element with ID "X" / When observable becomes true / HTML element receives a class of "Y"', function () {
			expect(1);

			// Arrange
			var called = false,
				elementId = 'modalElement',
				$element = $('#' + elementId),
				mode = 'Changed',
				propertyName = elementId + '_Is_' + mode;

			givenModelWithObservableProperty(propertyName, false, function (model) {
				Cu.Wire({ model: model });

				// Act
				model[propertyName].val(true);

				// Assert
				ok($element.hasClass(mode));
			});
		});
		
		test('Given a model with an Observable property with name in the format "X_Is_Y" / Given HTML element with ID "X" and class "Y" / When observable becomes false / HTML element loses a class of "Y"', function () {
			expect(1);

			// Arrange
			var called = false,
				elementId = 'modalElement',
				$element = $('#' + elementId),
				mode = 'Changed',
				propertyName = elementId + '_Is_' + mode;

			givenElementWithClass($element, mode, function () {
				givenModelWithObservableProperty(propertyName, true, function (model) {
					Cu.Wire({ model: model });

					// Act
					model[propertyName].val(false);

					// Assert
					ok(!$element.hasClass(mode));
				});
			});
		});
		
		test('Given a model with an Observable property with name in the format "X_Is_Y" / Given classless HTML element with ID "X" / Model binding is created ', function () {
			expect(1);

			var called = false,
				elementId = 'modalElement',
				$element = $('#' + elementId),
				mode = 'Changed',
				propertyName = elementId + '_Is_' + mode;

			givenModelWithObservableProperty(propertyName, false, function (model) {
				givenBlankViewBoundToModel(model, function (view) {
					assertModelBindingExists(view, propertyName, modelChangeHandlerName(propertyName));
				});
			});
		});
		
		test('Given a model with an Observable property with name in the format "X_Is_Y" / Given HTML element with ID "X", class "Y", and other classes / When observable becomes false / HTML element does not lost classes other than "Y"', function () {
			expect(1);

			// Arrange
			var called = false,
				elementId = 'modalElement',
				$element = $('#' + elementId),
				mode = 'Changed',
				extraClass = 'something',
				propertyName = elementId + '_Is_' + mode;

			givenElementWithClass($element, extraClass, function () {
				givenElementWithClass($element, mode, function () {
					givenModelWithObservableProperty(propertyName, true, function (model) {
						Cu.Wire({ model: model });

						// Act
						model[propertyName].val(false);

						// Assert
						ok($element.hasClass(extraClass));
					});
				});
			});
		});
		
		test('Given a model with an Observable property with name in the format "X_Is_Y" / Given classless HTML input with name "X" / When observable becomes true / HTML input receives a class of "Y"', function () {
			expect(1);

			// Arrange
			var called = false,
				elementId = 'namedModalInput',
				$element = $('input[name="' + elementId + '"]'),
				mode = 'Changed',
				propertyName = elementId + '_Is_' + mode;

			givenModelWithObservableProperty(propertyName, false, function (model) {
				Cu.Wire({ model: model });

				// Act
				model[propertyName].val(true);

				// Assert
				ok($element.hasClass(mode));
			});
		});
		
		test('Given a model with an Observable property with name in the format "X_Is_Y" / Given classless HTML input with name "X" / Model binding is created', function () {
			expect(1);

			// Arrange
			var called = false,
				elementId = 'namedModalInput',
				$element = $('input[name="' + elementId + '"]'),
				mode = 'Changed',
				propertyName = elementId + '_Is_' + mode;

			givenModelWithObservableProperty(propertyName, false, function (model) {
				givenBlankViewBoundToModel(model, function (view) {
					assertModelBindingExists(view, propertyName, modelChangeHandlerName(propertyName));
				});
			});
		});
		
		test('Given a model with an Observable property with name in the format "X_Is_Y" / Given HTML input with name "X" and class "Y" / When observable becomes false / HTML input loses a class of "Y"', function () {
			expect(1);

			// Arrange
			var called = false,
				elementId = 'namedModalInput',
				$element = $('input[name="' + elementId + '"]'),
				mode = 'Changed',
				propertyName = elementId + '_Is_' + mode;

			givenElementWithClass($element, mode, function () {
				givenModelWithObservableProperty(propertyName, true, function (model) {
					Cu.Wire({ model: model });

					// Act
					model[propertyName].val(false);

					// Assert
					ok(!$element.hasClass(mode));
				});
			});
		});
		
		test('Given a model with an Observable property with name in the format "X_Is_Y" / Given HTML input with name "X", class "Y", and other classes / When observable becomes false / HTML input does not lost classes other than "Y"', function () {
			expect(1);

			// Arrange
			var called = false,
				elementId = 'namedModalInput',
				$element = $('input[name="' + elementId + '"]'),
				mode = 'Changed',
				extraClass = 'something',
				propertyName = elementId + '_Is_' + mode;

			givenElementWithClass($element, extraClass, function () {
				givenElementWithClass($element, mode, function () {
					givenModelWithObservableProperty(propertyName, true, function (model) {
						Cu.Wire({ model: model });

						// Act
						model[propertyName].val(false);

						// Assert
						ok($element.hasClass(extraClass));
					});
				});
			});
		});
		
		test('Given a model with an Observable property with name in the format "X_Is_Y" / Given a view selector hash entry with name of Observable property and value of an HTML element with name "X" / When observable becomes true / HTML input receives a class of "Y"', function () {
			expect(1);

			// Arrange
			var called = false,
				elementId = 'modalElement',
				$element = $('#' + elementId),
				mode = 'Changed',
				selectorName = 'overreaction',
				propertyName = selectorName + '_Is_' + mode,
				selectors = {};

			selectors[selectorName] = '#' + elementId;
				
			givenModelWithObservableProperty(propertyName, false, function (model) {
				Cu.Wire({
					model: model,
					view: {
						selectorFor: selectors
					}
				});

				// Act
				model[propertyName].val(true);

				// Assert
				ok($element.hasClass(mode));
			});
		});
		
		test('Given a model with an Observable property with name in the format "X_Is_Y" / Given a view selector hash entry with name of Observable property and value of an HTML element with name "X" / Model binding is created ', function () {
			expect(1);
			
			var called = false,
				elementId = 'modalElement',
				$element = $('#' + elementId),
				mode = 'Changed',
				selectorName = 'overreaction',
				propertyName = selectorName + '_Is_' + mode,
				selectors = {};

			selectors[selectorName] = '#' + elementId;
				
			givenModelWithObservableProperty(propertyName, false, function (model) {
				var view = {
					selectorFor: selectors
				};
				
				Cu.Wire({
					model: model,
					view: view
				});

				assertModelBindingExists(view, propertyName, modelChangeHandlerName(propertyName));
			});
		});
		
		test('Given a model with an Observable property with name in the format "X_Is_Y" / Given a view selector hash entry with name of Observable property and value of an HTML element with name "X" and class "Y" / When observable becomes false / HTML input loses a class of "Y"', function () {
			expect(1);

			// Arrange
			var called = false,
				elementId = 'modalElement',
				$element = $('#' + elementId),
				mode = 'Changed',
				selectorName = 'overreaction',
				propertyName = selectorName + '_Is_' + mode,
				selectors = {};

			selectors[selectorName] = '#' + elementId;
			
			givenElementWithClass($element, mode, function () {
				givenModelWithObservableProperty(propertyName, true, function (model) {
					Cu.Wire({
						model: model,
						view: {
							selectorFor: selectors
						}
					});

					// Act
					model[propertyName].val(false);

					// Assert
					ok(!$element.hasClass(mode));
				});
			});
		});
		
		test('Given a model with an Observable property with name in the format "X_Is_Y" / Given a view selector hash entry with name of Observable property and value of an HTML element with class "Y", and other classes / When observable becomes false / HTML input does not lost classes other than "Y"', function () {
			expect(1);

			// Arrange
			var called = false,
				elementId = 'modalElement',
				$element = $('#' + elementId),
				mode = 'Changed',
				extraClass = 'something',
				selectorName = 'overreaction',
				propertyName = selectorName + '_Is_' + mode,
				selectors = {};
				
			selectors[selectorName] = '#' + elementId;

			givenElementWithClass($element, extraClass, function () {
				givenElementWithClass($element, mode, function () {
					givenModelWithObservableProperty(propertyName, true, function (model) {
						Cu.Wire({
							model: model,
							view: {
								selectorFor: selectors
							}
						});

						// Act
						model[propertyName].val(false);

						// Assert
						ok($element.hasClass(extraClass));
					});
				});
			});
		});
		
		test('Given a model with an Observable property / Given a view selector hash entry with name of Observable property and value of an HTML element / When observable changes / Content of HTML element selected by hashed selector is changed to match observable value', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'some awesome property',
				id = 'dynamicContent',
				initialValue = 'blah',
				oldContent = 'Something unremarkable',
				newContent = 'Something super special and important.',
				selectors = {};
			
			selectors[propertyName] = '#' + id;

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenTagWithIdContainsText(id, oldContent, function () {
					Cu.Wire({
						model: model,
						view: {
							selectorFor: selectors
						}
					});

					// Act
					model[propertyName].val(newContent);

					// Assert
					equal($('#' + id).html(), newContent);
				});
			});
		});
		
		test('Given a model with an Observable property / Given a view selector hash entry with name of Observable property and value of input in the HTML / When input changes / Observable value is changed to match value of input', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'something crazy',
				id = 'dynamicInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.',
				selectors = {};
			
			selectors[propertyName] = '#' + id;

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(id, oldValue, function () {
					Cu.Wire({
						model: model,
						view: {
							selectorFor: selectors
						}
					});
					
					
					$('#' + id).val(newValue);

					// Act
					$('#' + id).trigger('change');

					// Assert
					equal(model[propertyName].val(), newValue);
				});
			});
		});

		test('Given a model with an Observable property / Given a view selector hash entry with name of Observable property and value of input in the HTML / Input binding is created ', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'something crazy',
				id = 'dynamicInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.',
				selectors = {};
			
			selectors[propertyName] = '#' + id;

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(id, oldValue, function () {
					var view = {
						selectorFor: selectors
					}; 
					
					Cu.Wire({
						model: model,
						view: view
					});
										
					assertInputBindingExists(view, '#' + id, handlerNameFromInput(propertyName));
				});
			});
		});
		
		test('Given a model with an Observable property / Given a view selector hash entry with name of Observable property and value of input in the HTML / Model binding is created ', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'something crazy',
				id = 'dynamicInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.',
				selectors = {};
			
			selectors[propertyName] = '#' + id;

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(id, oldValue, function () {
					var view = {
						selectorFor: selectors
					}; 
					
					Cu.Wire({
						model: model,
						view: view
					});
										
					assertModelBindingExists(view, propertyName, modelChangeHandlerName(propertyName));
				});
			});
		});
		
		test('Given a model with an Observable property with name the same as the ID of an input in the HTML / When input changes / Observable value is changed to match value of input', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'dynamicInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(propertyName, oldValue, function () {
					Cu.Wire({ model: model });
					$('#' + propertyName).val(newValue);

					// Act
					$('#' + propertyName).trigger('change');

					// Assert
					equal(model[propertyName].val(), newValue);
				});
			});
		});
		
		test('Given a model with an Observable property with name the same as the ID of an input in the HTML / Input binding is created ', function () {
			expect(1);

			var called = false,
				propertyName = 'dynamicInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(propertyName, oldValue, function () {
					givenBlankViewBoundToModel(model, function (view) {
						assertInputBindingExists(view, '#' + propertyName, handlerNameFromInput(propertyName));
					});
				});
			});
		});
		
		test('Given a model with an Observable property with name the same as the ID of an input in the HTML / Model binding is created ', function () {
			expect(1);

			var called = false,
				propertyName = 'dynamicInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(propertyName, oldValue, function () {
					givenBlankViewBoundToModel(model, function (view) {
						assertModelBindingExists(view, propertyName, modelChangeHandlerName(propertyName));
					});
				});
			});
		});
		
		test('Given a model with an Observable property with name the same as the ID of an input in the HTML / When observable changes / Input value is changed to match observable value', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'dynamicInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(propertyName, oldValue, function () {
					Cu.Wire({ model: model });
					
					// Act
					model[propertyName].val(newValue);

					// Assert
					equal($('#' + propertyName).val(), newValue);
				});
			});
		});
		
		
		test('Given a model with an Observable property with name the same as the ID of an input in the HTML / Input binding is created ', function () {
			expect(1);

			var called = false,
				propertyName = 'dynamicInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(propertyName, oldValue, function () {
					givenBlankViewBoundToModel(model, function (view) {
						assertInputBindingExists(view, '#' + propertyName, handlerNameFromInput(propertyName));
					});
				});
			});
		});
		
		test('Given a model with an Observable property with name the same as the ID of an input in the HTML / Model binding is created ', function () {
			expect(1);

			var called = false,
				propertyName = 'dynamicInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(propertyName, oldValue, function () {
					givenBlankViewBoundToModel(model, function (view) {
						assertModelBindingExists(view, propertyName, modelChangeHandlerName(propertyName));
					});
				});
			});
		});
		
		test('Given a model with an Observable property with name the same as an input name in the HTML / When input changes / Observable value is changed to match value of input', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'namedInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithNameHasValue(propertyName, oldValue, function (selector) {
					Cu.Wire({ model: model });
					$(selector).val(newValue);

					// Act
					$(selector).trigger('change');

					// Assert
					equal(model[propertyName].val(), newValue);
				});
			});
		});
		
		test('Given a model with an Observable property with name the same as an input name in the HTML / When observable changes / Input value is changed to match observable value', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'namedInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithNameHasValue(propertyName, oldValue, function (selector) {
					Cu.Wire({ model: model });
					
					// Act
					model[propertyName].val(newValue);

					// Assert
					equal($(selector).val(), newValue);
				});
			});
		});
		
		test('Given a model with an Observable property named "Value" and a view with an editable scope element / When observable changes / HTML element content is changed to match observable value', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'Value',
				elementId = 'dynamicInput',
				$docScope = $('#' + elementId),
				initialValue = 'blah',
				oldContent = 'Something unremarkable',
				newContent = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenTagWithIdContainsText(elementId, oldContent, function () {
					Cu.Wire({
						view: {
							$documentScope: $docScope
						},
						model: model
					});

					// Act
					model[propertyName].val(newContent);

					// Assert
					equal($docScope.val(), newContent);
				});
			});
		});
		
		test('Given a model with an Observable property named "Value" and a view with an editable scope element / When input changes / Observable value is changed to match value of input', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'Value',
				elementId = 'dynamicInput',
				$docScope = $('#' + elementId),
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(elementId, oldValue, function () {
					Cu.Wire({
						view: {
							$documentScope: $docScope
						},
						model: model
					});
					$docScope.val(newValue);

					// Act
					$docScope.trigger('change');

					// Assert
					equal(model[propertyName].val(), newValue);
				});
			});
		});
		
		test('Given a model with an Observable property named "Value" and a view with an editable scope element / Input binding is created', function () {
			expect(1);

			var called = false,
				propertyName = 'Value',
				elementId = 'dynamicInput',
				$docScope = $('#' + elementId),
				initialValue = 'blah',
				oldContent = 'Something unremarkable',
				newContent = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenTagWithIdContainsText(elementId, oldContent, function () {
					var view = {
						$documentScope: $docScope
					};
					
					Cu.Wire({
						view: view,
						model: model
					});

					assertInputBindingExists(view, '#' + elementId, handlerNameFromInput(propertyName));
				});
			});
		});
		
		test('Given a model with an Observable property named "Value" and a view with an editable scope element / Model binding is created', function () {
			expect(1);

			var called = false,
				propertyName = 'Value',
				elementId = 'dynamicInput',
				$docScope = $('#' + elementId),
				initialValue = 'blah',
				oldContent = 'Something unremarkable',
				newContent = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenTagWithIdContainsText(elementId, oldContent, function () {
					var view = {
						$documentScope: $docScope
					};
					
					Cu.Wire({
						view: view,
						model: model
					});

					assertModelBindingExists(view, propertyName, modelChangeHandlerName(propertyName));
				});
			});
		});
		
		test('Given a model with an Observable property named "Is_X" and a view with a classless scope element / When observable becomes true / HTML element receives a class of X', function () {
			expect(1);

			// Arrange
			var called = false,
				mode = 'changed',
				propertyName = 'Is_' + mode,
				elementId = 'modalElement',
				$docScope = $('#' + elementId),
				initialValue = false;

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				Cu.Wire({
					view: {
						$documentScope: $docScope
					},
					model: model
				});

				// Act
				model[propertyName].val(true);

				// Assert
				ok($docScope.hasClass(mode));
			});
		});
		
		test('Given a model with an Observable property named "Is_X" and a view with a classless scope element / Model binding is created ', function () {
			expect(1);

			// Arrange
			var called = false,
				mode = 'changed',
				propertyName = 'Is_' + mode,
				elementId = 'modalElement',
				$docScope = $('#' + elementId),
				initialValue = false;

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				var view = {
					$documentScope: $docScope
				};
				
				Cu.Wire({
					view: view,
					model: model
				});

				assertModelBindingExists(view, propertyName, modelChangeHandlerName(propertyName));
			});
		});
		
		test('Given a model with an Observable property named "Is_X" and a view with a classed scope element / When observable becomes false / HTML element loses class of X', function () {
			expect(1);

			// Arrange
			var called = false,
				mode = 'changed',
				propertyName = 'Is_' + mode,
				elementId = 'modalElement',
				$docScope = $('#' + elementId),
				initialValue = true;

			givenElementWithClass($docScope, mode, function() {
				givenModelWithObservableProperty(propertyName, initialValue, function (model) {
					Cu.Wire({
						view: {
							$documentScope: $docScope
						},
						model: model
					});

					// Act
					model[propertyName].val(false);

					// Assert
					ok(!$docScope.hasClass(mode));
				});
			});
		});

		test('Given a model with an Observable property named "Is_X" and a view with a multi-classed scope element / When observable becomes false / HTML element does not lose non-X classes', function () {
			expect(1);

			// Arrange
			var called = false,
				mode = 'changed',
				propertyName = 'Is_' + mode,
				elementId = 'modalElement',
				$docScope = $('#' + elementId),
				initialValue = true,
				extraClass = 'something';
			
			givenElementWithClass($docScope, mode, function() {			
				givenElementWithClass($docScope, extraClass, function() {
					givenModelWithObservableProperty(propertyName, initialValue, function (model) {
						Cu.Wire({
							view: {
								$documentScope: $docScope
							},
							model: model
						});

						// Act
						model[propertyName].val(false);

						// Assert
						ok($docScope.hasClass(extraClass));
					});
				});
			});
		});

		test('Given a model with an Observable property with name not found in HTML or selector hash / Constructor does not throw', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'iDoNotExist',
				initialValue = 'blah',
				newContent = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				Cu.Wire({ model: model });

				// Act
				model[propertyName].val(newContent);

				// Assert
				ok(true);
			});
		});

		// Test HTML scoping.
		test('Given a model with an Observable property with name the same as an ID of an input outside the scope / When input changes / Observable value does not change', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'dynamicInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(propertyName, oldValue, function () {
					Cu.Wire({
						model: model,
						view: {
							$documentScope: $('#subView')
						}
					});

					$('#' + propertyName).val(newValue);

					// Act
					$('#' + propertyName).trigger('change');

					// Assert
					equal(model[propertyName].val(), initialValue);
				});
			});
		});
		
		// Test HTML scoping.
		test('Given a model with an Observable property with name the same as an ID of an input outside the compound scopes / When input changes / Observable value does not change', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'dynamicInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(propertyName, oldValue, function () {
					Cu.Wire({
						model: model,
						view: {
							$documentScope: $('#subView').add($('#subView2'))
						}
					});

					$('#' + propertyName).val(newValue);

					// Act
					$('#' + propertyName).trigger('change');

					// Assert
					equal(model[propertyName].val(), initialValue);
				});
			});
		});

		// Test HTML scoping.
		test('Given a model with an Observable property with name the same as an ID of an input inside the compound scopes / When input changes / Observable value is changed to match value of input', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'compoundScopedInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(propertyName, oldValue, function () {
					Cu.Wire({
						model: model,
						view: {
							$documentScope: $('#subView').add($('#subView2'))
						}
					});

					$('#' + propertyName).val(newValue);

					// Act
					$('#' + propertyName).trigger('change');

					// Assert
					equal(model[propertyName].val(), newValue);
				});
			});
		});
		
		test('Given a view with a method with a name of X_ModelChanged / Given an Observable model property called X / Changing the Observable value calls the view handler ', function () {
			var called = false,
				initialValue = 'something old',
				newValue = 'something new',
				propertyName = 'iAmImportant',
				handlerName = modelChangeHandlerName(propertyName),
				view;

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {			
				var view = {};
				view[handlerName] = function () { called = true; };

				Cu.Wire({
					model: model,
					view: view
				});

				model[propertyName].val(newValue);

				ok(called);
			});
		});
		
		test('Given a view with a method with a name of X_ModelChanged / Given an Observable model property called X / Model binding is created ', function () {
			var called = false,
				initialValue = 'something old',
				propertyName = 'iAmImportant',
				handlerName = modelChangeHandlerName(propertyName),
				view;

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {			
				var view = {};
				view[handlerName] = function () { called = true; };
				
				Cu.Wire({
					model: model,
					view: view
				});

				assertModelBindingExists(view, propertyName, handlerName);
			});
		});
		
		test('Given a view with a method with a name of X_ViewChanged / Given an input with name of X in the HTML / Changing the input calls the property from the extension source.', function () {
			// Arrange
			var called = false,
				extendSource,
				subject,
				propertyName = 'namedInput';

			var view = {};
			view[propertyName + '_ViewChanged'] = function () { called = true; };

			Cu.Wire({
				model: {},
				view: view
			});

			// Act
			$('[name=' + propertyName + ']').trigger('change');

			// Assert
			ok(called);
		});
		
		test('Given a view with a method with a name of X_ViewChanged / Given an input with name of X in the HTML / Input binding is created ', function () {
			// Arrange
			var called = false,
				extendSource,
				subject,
				propertyName = 'namedInput',
				handlerName = handlerNameFromInput(propertyName);

			var view = {};
			view[handlerName] = function () { called = true; };

			Cu.Wire({
				model: {},
				view: view
			});

			assertInputBindingExists(view, '[name=' + propertyName + ']', handlerName);
		});
		
		test('Given a view with a method with a name of X_ViewChanged / Given an input with ID of X in the HTML / Changing the input calls the property from the extension source.', function () {
			// Arrange
			var called = false,
				extendSource,
				subject,
				propertyName = 'dynamicInput';

			var view = {};
			view[propertyName + '_ViewChanged'] = function () { called = true; };

			Cu.Wire({
				model: {},
				view: view
			});

			// Act
			$('#' + propertyName).trigger('change');

			// Assert
			ok(called);
		});
		
		test('Given a view with a method with a name of X_ViewChanged / Given an input with ID of X in the HTML / Input binding is created ', function () {
			// Arrange
			var called = false,
				extendSource,
				subject,
				propertyName = 'dynamicInput',
				handlerName = handlerNameFromInput(propertyName);

			var view = {};
			view[handlerName] = function () { called = true; };

			Cu.Wire({
				model: {},
				view: view
			});

			assertInputBindingExists(view, '#' + propertyName, handlerName);
		});

		test('Given a view with a method with a name of X_Clicked / Given a button with ID of X in the HTML / Clicking the button calls the property from the extension source.', function () {
			// Arrange
			var called = false,
				extendSource,
				subject,
				propertyName = 'helloInputButton';

			var view = {};
			view[propertyName + '_Clicked'] = function () { called = true; };

			Cu.Wire({
				model: {},
				view: view
			});

			// Act
			$('#' + propertyName).trigger('click');

			// Assert
			ok(called);
		});
		
		test('Given a view with a method with a name of X_Clicked / Given a button with ID of X in the HTML / Input binding is created ', function () {
			// Arrange
			var called = false,
				extendSource,
				subject,
				propertyName = 'helloInputButton',
				handlerName = handlerNameFromClickable(propertyName);

			var view = {};
			view[handlerName] = function () { called = true; };

			Cu.Wire({
				model: {},
				view: view
			});

			assertInputBindingExists(view, '#' + propertyName, handlerName);
		});
		
		test('Given an observable bound to an input / When syncronizeFromModel called / Input receives observable value. ', function () {

			var called = false,
				propertyName = 'dynamicInput',
				initialValue = 'blah',
				oldContent = 'Something unremarkable';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(propertyName, oldContent, function () {
					givenBlankViewBoundToModel(model, function (view) {
						view.syncronizeFromModel();
						
						equal($('#' + propertyName).val(), initialValue);
					});
				});
			});
		});
		
		test('Given an observable bound to an input / When syncronizeFromInputs called / Observable receives input value. ', function () {

			var called = false,
				propertyName = 'dynamicInput',
				initialValue = 'blah',
				inputContent = 'Something unremarkable';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(propertyName, inputContent, function () {
					givenBlankViewBoundToModel(model, function (view) {
						view.syncronizeFromInputs();
				
						equal(model[propertyName].val(), inputContent);
					});
				});
			});
		});
		
		test('Given an observable bound to an input / When initializeFromModel called / Input receives observable value. ', function () {

			var called = false,
				propertyName = 'dynamicInput',
				initialValue = 'blah',
				oldContent = 'Something unremarkable';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(propertyName, oldContent, function () {
					
					Cu.Wire({
						model: model
					}).initializeFromModel();
						
					equal($('#' + propertyName).val(), initialValue);
				});
			});
		});
		
		test('Given an observable bound to an input / When initializeFromInputs called / Observable receives input value. ', function () {

			var called = false,
				propertyName = 'dynamicInput',
				initialValue = 'blah',
				inputContent = 'Something unremarkable';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(propertyName, inputContent, function () {
					
					Cu.Wire({
						model: model
					}).initializeFromInputs();
			
					equal(model[propertyName].val(), inputContent);
				});
			});
		});
	</script>
</html>