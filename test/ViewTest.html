<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
	<head>
		<title>JS Infrastructure Tests - View</title>
		<link href="../ext/qunit.css" rel="stylesheet" type="text/css" />

		<script src="../ext/jquery-1.7.1.min.js" type="text/javascript"></script>
		<script src="../ext/underscore-1.2.2.min.js" type="text/javascript"></script>
		<script src="../ext/qunit.js" type="text/javascript"></script>
		<script src="../src/copper.js" type="text/javascript"></script>
	</head>
	<body>
		<h1 id="qunit-header">JS Infrastructure Tests - View</h1>
		<h2 id="qunit-banner"></h2>
		<div id="qunit-testrunner-toolbar"></div>
		<h2 id="qunit-userAgent"></h2>
		<ol id="qunit-tests"></ol>
		<div id="qunit-fixture">
			<a id="helloAnchor" href="#" />
			<button id="helloButton" />
			<input id="helloInputSubmit" type="submit" />
			<input id="helloInputButton" type="button" />
			<input id="helloInputReset" type="reset" />
			<p id="dynamicContent"></p>
			<input id="dynamicInput" type="text" />
			<div id="subView">
			</div>
		</div>
	</body>
	<script>
		module('Observable');

		test('Given initial value, when constructed, accessor yields initial value.', function () {
			// Arrange
			var value = 'SomethingSomething',
				subject;

			// Act
			subject = new copper.Observable(value);

			// Assert
			equal(subject.val(), value);
		});

		test('Given initial value, when new value set, accessor yields new value.', function () {
			// Arrange
			var replacementValue = 'SomethingNew',
				subject = new copper.Observable('SomethingSomething');

			// Act
			subject.val(replacementValue);

			// Assert
			equal(subject.val(), replacementValue);
		});

		test('Given subscription, when new value set, handler called with new value.', function () {
			// Arrange
			var replacementValue = 'SomethingNew',
				subject = new copper.Observable('SomethingSomething'),
				storedByHandler = undefined;

			subject.subscribe(function (newValue) {
				storedByHandler = newValue;
			});

			// Act
			subject.val(replacementValue);

			// Assert
			equal(storedByHandler, replacementValue);
		});

		test('Given multiple subscriptions, when new value set, handlers all called with new value.', function () {
			// Arrange
			var replacementValue = 'SomethingNew',
				subject = new copper.Observable('SomethingSomething'),
				storedByHandlers = [],
				handlerCount = 7;

			_.range(0, handlerCount).forEach(function () {
				subject.subscribe(function (newValue) {
					storedByHandlers.push(newValue);
				});
			});

			// Act
			subject.val(replacementValue);

			// Assert
			ok(storedByHandlers.length == handlerCount
				&& _(storedByHandlers).without(replacementValue).length == 0);
		});

		test('Given multiple subscriptions, and given a handler is unsubscribed, when new value set, handlers all called with new value.', function () {
			// Arrange
			var replacementValue = 'SomethingNew',
				subject = new copper.Observable('SomethingSomething'),
				handler1Called = false,
				handler1 = function () { handler1Called = true },
				handler2Called = false,
				handler2 = function () { handler2Called = true }

			subject.subscribe(handler1);
			subject.subscribe(handler2);

			// Act
			subject.unsubscribe(handler1);
			subject.val(replacementValue);

			// Assert
			ok(handler2Called && !handler1Called);
		});

		test('Given multiple subscriptions, and given release was called, when new value set, handlers all called with new value.', function () {
			// Arrange
			var replacementValue = 'SomethingNew',
				subject = new copper.Observable('SomethingSomething'),
				handler1Called = false,
				handler1 = function () { handler1Called = true },
				handler2Called = false,
				handler2 = function () { handler2Called = true }

			subject.subscribe(handler1);
			subject.subscribe(handler2);

			// Act
			subject.release();
			subject.val(replacementValue);

			// Assert
			ok(!handler1Called && !handler2Called);
		});
		
		module("ObservableCollection");

		test('Given no initial value, when constructed, accessor yields empty array.', function () {
			// Arrange
			var subject;

			// Act
			subject = new copper.ObservableCollection();

			// Assert
			deepEqual(subject.val(), []);
		});

		test('Given initial value, when constructed, accessor yields initial value.', function () {
			// Arrange
			var value = [1, 2, 3],
				subject;

			// Act
			subject = new copper.ObservableCollection(value);

			// Assert
			equal(subject.val(), value);
		});

		test('Given initial value, when new collection replaced, accessor yields new value.', function () {
			// Arrange
			var replacementValue = ['SomethingNew', 'Something 2', 'Something 3'],
				subject = new copper.ObservableCollection(['SomethingSomething', 'Wonderwall', 'Splendor']);

			// Act
			subject.val(replacementValue);

			// Assert
			equal(subject.val(), replacementValue);
		});

		test('Given subscription, when new value set, handler called with new value.', function () {
			// Arrange
			var replacementValue = ['SomethingNew', 'Something 2', 'Something 3'],
				subject = new copper.ObservableCollection(['SomethingSomething', 'Wonderwall', 'Splendor']),
				storedByHandler = undefined;

			subject.subscribe('collectionReplaced', function (newValue) {
				storedByHandler = newValue;
			});

			// Act
			subject.val(replacementValue);

			// Assert
			equal(storedByHandler, replacementValue);
		});
		
		test('Given existing collection, when value added, accessor yields array with value added to end.', function () {
			// Arrange
			var initialValue = ['A', 'B', 'D', 'E'],
				subject = new copper.ObservableCollection(initialValue),
				valueToAdd = 'C',
				expectedValue;

			expectedValue = initialValue.slice(0);
			expectedValue.push(valueToAdd);
				
			// Act
			subject.add(valueToAdd);

			// Assert
			deepEqual(initialValue, expectedValue);
		});
		
		test('Given existing collection, when value added at index, accessor yields array with added value.', function () {
			// Arrange
			var initialValue = ['A', 'B', 'D', 'E'],
				subject = new copper.ObservableCollection(initialValue),
				valueToAdd = 'C',
				indexToAdd = 2,
				expectedValue;

			expectedValue = initialValue.slice(0);
			expectedValue.splice(indexToAdd, 0, valueToAdd);
				
			// Act
			subject.add(valueToAdd, indexToAdd);

			// Assert
			deepEqual(initialValue, expectedValue);
		});

		test('Given subscription, when value added, handler called with new value and index.', function () {
			// Arrange
			var subject = new copper.ObservableCollection(['A', 'B', 'D', 'E']),
				valueToAdd = 'C',
				indexToAdd = '2',
				valueAdded,
				addedIndex;

			subject.subscribe('itemAdded', function (item, index) {
				valueAdded = item;
				addedIndex = index;
			});

			// Act
			subject.add(valueToAdd, indexToAdd);

			// Assert
			equal(valueAdded, valueToAdd);
			equal(addedIndex, indexToAdd);
		});
		
		test('Given existing collection, when value removed, accessor yields array with value removed.', function () {
			// Arrange
			var initialValue = ['A', 'C', 'B', 'E', 'D'],
				subject = new copper.ObservableCollection(initialValue),
				valueToRemove = 'C',
				expectedValue = initialValue;
				
			expectedValue.splice(expectedValue.indexOf(valueToRemove), 1);
				
			// Act
			subject.remove(valueToRemove);

			// Assert
			deepEqual(initialValue, expectedValue);
		});

		test('Given subscription, when value removed, handler called with new value and index.', function () {
			// Arrange
			var initialValue = ['A', 'C', 'B', 'E', 'D'],
				subject = new copper.ObservableCollection(initialValue),
				valueToRemove = 'C',
				indexToRemove = initialValue.indexOf(valueToRemove),
				valueremoved,
				removedIndex;

			subject.subscribe('itemRemoved', function (item, index) {
				valueremoved = item;
				removedIndex = index;
			});

			// Act
			subject.remove(valueToRemove);

			// Assert
			equal(valueremoved, valueToRemove);
			equal(removedIndex, indexToRemove);
		});
		
		test('Given existing collection, when value removed at index, accessor yields array with value removed.', function () {
			// Arrange
			var initialValue = ['A', 'C', 'B', 'E', 'D'],
				subject = new copper.ObservableCollection(initialValue),
				indexToRemove = 3;
				expectedValue = initialValue;
				
			expectedValue.splice(indexToRemove, 1);
				
			// Act
			subject.removeAt(indexToRemove);

			// Assert
			deepEqual(initialValue, expectedValue);
		});

		test('Given subscription, when value removed at index, handler called with removed value and index.', function () {
			// Arrange
			var initialValue = ['A', 'C', 'B', 'E', 'D'],
				subject = new copper.ObservableCollection(initialValue),
				indexToRemove = 4,
				valueToRemove = initialValue[indexToRemove],
				valueRemoved,
				removedIndex;

			subject.subscribe('itemRemoved', function (item, index) {
				valueRemoved = item;
				removedIndex = index;
			});

			// Act
			subject.removeAt(indexToRemove);

			// Assert
			equal(valueRemoved, valueToRemove);
			equal(removedIndex, indexToRemove);
		});
		
		module('SmartEvent');

		test('ctor / Given name / Initializes name property to specified value', function () {
			// Arrange
			var name = 'SecurityBreach',
				subject;

			// Act
			subject = new copper.SmartEvent(name);

			// Assert
			equal(subject.name, name);
		});

		test('ctor / Initializes handlers property to empty', function () {
			// Arrange
			var subject;

			// Act
			subject = new copper.SmartEvent();

			// Assert
			deepEqual(subject.handlers, []);
		});

		test('subscribe / Given function / Adds handler to handlers list', function () {
			// Arrange
			var subject = new copper.SmartEvent(),
				handler = function () { };

			// Act
			subject.subscribe(handler);

			// Assert
			deepEqual(subject.handlers, [handler]);
		});

		test('subscribe / Given function already added / Does not add handler again', function () {
			// Arrange
			var subject = new copper.SmartEvent(),
				handler1 = function () { },
				handler2 = function () { };

			subject.subscribe(handler1);
			subject.subscribe(handler2);

			// Act
			subject.subscribe(handler1);

			// Assert
			deepEqual(subject.handlers, [handler1, handler2]);
		});

		test('subscribe / Given a non-function value / Does nothing', function () {
			// Arrange
			var subject = new copper.SmartEvent();

			// Act
			subject.subscribe({ something: 'not a function' });

			// Assert
			deepEqual(subject.handlers, []);
		});

		test('unsubscribe / Given a function already added / Removes handler', function () {
			// Arrange
			var subject = new copper.SmartEvent(),
				handler1 = function () { },
				handler2 = function () { };

			subject.subscribe(handler1);
			subject.subscribe(handler2);

			// Act
			subject.unsubscribe(handler2);

			// Assert
			deepEqual(subject.handlers, [handler1]);
		});

		test('unsubscribe / Given a function not yet added / Does nothing', function () {
			// Arrange
			var subject = new copper.SmartEvent(),
				handler1 = function () { },
				handler2 = function () { };

			subject.subscribe(handler1);
			
			// Act
			subject.unsubscribe(handler2);

			// Assert
			deepEqual(subject.handlers, [handler1]);
		});

		test('unsubscribe / Given a non-function value / Does nothing', function () {
			// Arrange
			var subject = new copper.SmartEvent(),
				handler = function () { };

			subject.subscribe(handler);

			// Act
			subject.unsubscribe({ something: 'not a function' });

			// Assert
			deepEqual(subject.handlers, [handler]);
		});

		test('raise / Calls each subscribed function', function () {
			// Arrange
			var subject = new copper.SmartEvent(),
				handler1Called = false,
				handler1 = function () { handler1Called = true },
				handler2Called = false,
				handler2 = function () { handler2Called = true },
				handler3Called = false,
				handler3 = function () { handler3Called = true };

			subject.subscribe(handler1);
			subject.subscribe(handler2);
			subject.subscribe(handler3);

			// Act
			subject.raise();

			// Assert
			ok(_([handler1Called, handler2Called, handler3Called]).all(function (item) { return item; }));
		});
		
		module('View');

		givenModelWithFunctionProperty = function (propertyName, propertyFunction, continueTest) {
			var model = {};
			model[propertyName] = propertyFunction;
			continueTest(model);
		}

		test('Given a model with a function property with name the same ID as an anchor in the HTML / When anchor clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				propertyName = 'helloAnchor',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				copper.Bind({ model: model });

				// Act
				$('#' + propertyName).click();
			});

			// Assert
			ok(called);
		});

		test('Given a model with a function property with name the same ID as a button in the HTML / When button clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				propertyName = 'helloButton',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				copper.Bind({ model: model });

				// Act
				$('#' + propertyName).click();
			});

			// Assert
			ok(called);
		});

		test('Given a model with a function property with name the same ID as a submit input in the HTML / When submit input clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				propertyName = 'helloInputSubmit',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				copper.Bind({ model: model });

				// Act
				$('#' + propertyName).click();
			});

			// Assert
			ok(called);
		});

		test('Given a model with a function property with name the same ID as a button input in the HTML / When button input clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				propertyName = 'helloInputButton',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				copper.Bind({ model: model });

				// Act
				$('#' + propertyName).click();
			});

			// Assert
			ok(called);
		});

		test('Given a model with a function property with name the same ID as a reset input in the HTML / When reset input clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				propertyName = 'helloInputReset',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				copper.Bind({ model: model });

				// Act
				$('#' + propertyName).click();
			});

			// Assert
			ok(called);
		});


		test('Given a model with a function property with name not found in HTML / Constructor does not throw', function () {
			expect(1);

			// Arrange
			var propertyName = 'iDoNotExist';

			givenModelWithFunctionProperty(propertyName, function () { }, function (model) {
				copper.Bind({ model: model });

				// Assert
				ok(true);
			});
		});

		var givenModelWithObservableProperty = function (propertyName, initialValue, continueTest) {
			var model = {};
			model[propertyName] = new copper.Observable(initialValue);
			continueTest(model);
		};

		var givenTagWithIdContainsText = function (id, content, continueTest) {
			$('#' + id).html(content);
			continueTest();
		};

		var givenInputWithIdHasValue = function (id, value, continueTest) {
			$('#' + id).val(value);
			continueTest();
		};

		test('Given a model with an Observable property with name the same ID as an element in the HTML / When observable changes / HTML element content is changed to match observable value', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'dynamicContent',
				initialValue = 'blah',
				oldContent = 'Something unremarkable',
				newContent = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenTagWithIdContainsText(propertyName, oldContent, function () {
					copper.Bind({ model: model });

					// Act
					model[propertyName].val(newContent);

					// Assert
					equal($('#' + propertyName).html(), newContent);
				});
			});
		});

		test('Given a model with an Observable property with name the same ID as an input in the HTML / When input changes / Observable value is changed to match value of input', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'dynamicInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(propertyName, oldValue, function () {
					copper.Bind({ model: model });
					$('#' + propertyName).val(newValue);

					// Act
					$('#' + propertyName).trigger('change');

					// Assert
					equal(model[propertyName].val(), newValue);
				});
			});
		});

		test('Given a model with an Observable property with name not found in HTML / Constructor does not throw', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'iDoNotExist',
				initialValue = 'blah',
				newContent = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				copper.Bind({ model: model });

				// Act
				model[propertyName].val(newContent);

				// Assert
				ok(true);
			});
		});

		// Test HTML scoping.
		test('Given a model with an Observable property with name the same ID as an input outside the scope / When input changes / Observable value does not change', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'dynamicInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(propertyName, oldValue, function () {
					copper.Bind({
						model: model,
						view: {
							$documentScope: $('#subView')
						}
					});

					$('#' + propertyName).val(newValue);

					// Act
					$('#' + propertyName).trigger('change');

					// Assert
					equal(model[propertyName].val(), initialValue);
				});
			});
		});

		test('Given an view with a method with a name of X_ViewChanged / Given an input with ID of X in the HTML / Changing the input calls the property from the extension source.', function () {
			// Arrange
			var called = false,
				extendSource,
				subject,
				propertyName = 'dynamicInput';

			view = {};
			view[propertyName + '_ViewChanged'] = function () { called = true; };

			copper.Bind({
				model: {},
				view: view
			});

			// Act
			$('#' + propertyName).trigger('change');

			// Assert
			ok(called);
		});

		test('Given an view with a method with a name of X_Clicked / Given a button with ID of X in the HTML / Clicking the button calls the property from the extension source.', function () {
			// Arrange
			var called = false,
				extendSource,
				subject,
				propertyName = 'helloInputButton';

			view = {};
			view[propertyName + '_Clicked'] = function () { called = true; };

			copper.Bind({
				model: {},
				view: view
			});

			// Act
			$('#' + propertyName).trigger('click');

			// Assert
			ok(called);
		});
	</script>
</html>