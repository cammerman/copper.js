<!DOCTYPE html>
<html dir="ltr" lang="en-US">
	<head>
		<title>JS Infrastructure Tests - View</title>
		<link href="../ext/qunit.css" rel="stylesheet" type="text/css" />

		<script src="../ext/jquery-1.7.1.min.js" type="text/javascript"></script>
		<script src="../ext/underscore-1.2.2.min.js" type="text/javascript"></script>
		<script src="../ext/qunit.js" type="text/javascript"></script>
		<script src="../src/copper.js" type="text/javascript"></script>
	</head>
	<body>
		<h1 id="qunit-header">JS Infrastructure Tests - View</h1>
		<h2 id="qunit-banner"></h2>
		<div id="qunit-testrunner-toolbar"></div>
		<h2 id="qunit-userAgent"></h2>
		<ol id="qunit-tests"></ol>
		<div id="qunit-fixture">
			<a id="helloAnchor" href="#" />
			<button id="helloButton" />
			<input id="helloInputSubmit" type="submit" />
			<input id="helloInputButton" type="button" />
			<input id="helloInputReset" type="reset" />
			<p id="dynamicContent"></p>
			<p id="dynamicClass"></p>
			<input id="dynamicInput" type="text" />
			<input name="namedInput" type="text" />
			<div id="subView">
			</div>
			<div id="modalElement"></div>
		</div>
	</body>
	<script>
		module('Observable');

		test('Given initial value, when constructed, accessor yields initial value.', function () {
			// Arrange
			var value = 'SomethingSomething',
				subject;

			// Act
			subject = new copper.Observable(value);

			// Assert
			equal(subject.val(), value);
		});

		test('Given initial value, when new value set, accessor yields new value.', function () {
			// Arrange
			var replacementValue = 'SomethingNew',
				subject = new copper.Observable('SomethingSomething');

			// Act
			subject.val(replacementValue);

			// Assert
			equal(subject.val(), replacementValue);
		});

		test('Given subscription, when new value set, handler called with new value.', function () {
			// Arrange
			var replacementValue = 'SomethingNew',
				subject = new copper.Observable('SomethingSomething'),
				storedByHandler = undefined;

			subject.subscribe(function (newValue) {
				storedByHandler = newValue;
			});

			// Act
			subject.val(replacementValue);

			// Assert
			equal(storedByHandler, replacementValue);
		});

		test('Given multiple subscriptions, when new value set, handlers all called with new value.', function () {
			// Arrange
			var replacementValue = 'SomethingNew',
				subject = new copper.Observable('SomethingSomething'),
				storedByHandlers = [],
				handlerCount = 7;

			_.range(0, handlerCount).forEach(function () {
				subject.subscribe(function (newValue) {
					storedByHandlers.push(newValue);
				});
			});

			// Act
			subject.val(replacementValue);

			// Assert
			ok(storedByHandlers.length == handlerCount
				&& _(storedByHandlers).without(replacementValue).length == 0);
		});

		test('Given multiple subscriptions, and given a handler is unsubscribed, when new value set, handlers all called with new value.', function () {
			// Arrange
			var replacementValue = 'SomethingNew',
				subject = new copper.Observable('SomethingSomething'),
				handler1Called = false,
				handler1 = function () { handler1Called = true },
				handler2Called = false,
				handler2 = function () { handler2Called = true }

			subject.subscribe(handler1);
			subject.subscribe(handler2);

			// Act
			subject.unsubscribe(handler1);
			subject.val(replacementValue);

			// Assert
			ok(handler2Called && !handler1Called);
		});

		test('Given multiple subscriptions, and given release was called, when new value set, handlers all called with new value.', function () {
			// Arrange
			var replacementValue = 'SomethingNew',
				subject = new copper.Observable('SomethingSomething'),
				handler1Called = false,
				handler1 = function () { handler1Called = true },
				handler2Called = false,
				handler2 = function () { handler2Called = true }

			subject.subscribe(handler1);
			subject.subscribe(handler2);

			// Act
			subject.release();
			subject.val(replacementValue);

			// Assert
			ok(!handler1Called && !handler2Called);
		});
		
		module('ObservableCollection');

		test('Given no initial value, when constructed, accessor yields empty array.', function () {
			// Arrange
			var subject;

			// Act
			subject = new copper.ObservableCollection();

			// Assert
			deepEqual(subject.val(), []);
		});

		test('Given initial value, when constructed, accessor yields initial value.', function () {
			// Arrange
			var value = [1, 2, 3],
				subject;

			// Act
			subject = new copper.ObservableCollection(value);

			// Assert
			equal(subject.val(), value);
		});

		test('Given initial value, when new collection replaced, accessor yields new value.', function () {
			// Arrange
			var replacementValue = ['SomethingNew', 'Something 2', 'Something 3'],
				subject = new copper.ObservableCollection(['SomethingSomething', 'Wonderwall', 'Splendor']);

			// Act
			subject.val(replacementValue);

			// Assert
			equal(subject.val(), replacementValue);
		});

		test('Given subscription, when new value set, handler called with new value.', function () {
			// Arrange
			var replacementValue = ['SomethingNew', 'Something 2', 'Something 3'],
				subject = new copper.ObservableCollection(['SomethingSomething', 'Wonderwall', 'Splendor']),
				storedByHandler = undefined;

			subject.subscribe('collectionReplaced', function (newValue) {
				storedByHandler = newValue;
			});

			// Act
			subject.val(replacementValue);

			// Assert
			equal(storedByHandler, replacementValue);
		});
		
		test('Given existing collection, when value added, accessor yields array with value added to end.', function () {
			// Arrange
			var initialValue = ['A', 'B', 'D', 'E'],
				subject = new copper.ObservableCollection(initialValue),
				valueToAdd = 'C',
				expectedValue;

			expectedValue = initialValue.slice(0);
			expectedValue.push(valueToAdd);
				
			// Act
			subject.add(valueToAdd);

			// Assert
			deepEqual(initialValue, expectedValue);
		});
		
		test('Given subscription, when value added, handler called with new value and index.', function () {
			// Arrange
			var initialValue = ['A', 'B', 'D', 'E'],
				subject = new copper.ObservableCollection(initialValue),
				valueToAdd = 'C',
				indexToAdd = initialValue.length,
				valueAdded,
				addedIndex;

			subject.subscribe('itemAdded', function (item, index) {
				valueAdded = item;
				addedIndex = index;
			});

			// Act
			subject.add(valueToAdd);

			// Assert
			equal(valueAdded, valueToAdd);
			equal(addedIndex, indexToAdd);
		});
		
		test('Given existing collection, when value added at index, accessor yields array with added value.', function () {
			// Arrange
			var initialValue = ['A', 'B', 'D', 'E'],
				subject = new copper.ObservableCollection(initialValue),
				valueToAdd = 'C',
				indexToAdd = 2,
				expectedValue;

			expectedValue = initialValue.slice(0);
			expectedValue.splice(indexToAdd, 0, valueToAdd);
				
			// Act
			subject.add(valueToAdd, indexToAdd);

			// Assert
			deepEqual(initialValue, expectedValue);
		});

		test('Given subscription, when value added, handler called with new value and index.', function () {
			// Arrange
			var subject = new copper.ObservableCollection(['A', 'B', 'D', 'E']),
				valueToAdd = 'C',
				indexToAdd = '2',
				valueAdded,
				addedIndex;

			subject.subscribe('itemAdded', function (item, index) {
				valueAdded = item;
				addedIndex = index;
			});

			// Act
			subject.add(valueToAdd, indexToAdd);

			// Assert
			equal(valueAdded, valueToAdd);
			equal(addedIndex, indexToAdd);
		});
		
		test('Given existing collection, when value removed, accessor yields array with value removed.', function () {
			// Arrange
			var initialValue = ['A', 'C', 'B', 'E', 'D'],
				subject = new copper.ObservableCollection(initialValue),
				valueToRemove = 'C',
				expectedValue = initialValue;
				
			expectedValue.splice(expectedValue.indexOf(valueToRemove), 1);
				
			// Act
			subject.remove(valueToRemove);

			// Assert
			deepEqual(initialValue, expectedValue);
		});

		test('Given subscription, when value removed, handler called with new value and index.', function () {
			// Arrange
			var initialValue = ['A', 'C', 'B', 'E', 'D'],
				subject = new copper.ObservableCollection(initialValue),
				valueToRemove = 'C',
				indexToRemove = initialValue.indexOf(valueToRemove),
				valueremoved,
				removedIndex;

			subject.subscribe('itemRemoved', function (item, index) {
				valueremoved = item;
				removedIndex = index;
			});

			// Act
			subject.remove(valueToRemove);

			// Assert
			equal(valueremoved, valueToRemove);
			equal(removedIndex, indexToRemove);
		});
		
		test('Given existing collection, when value removed at index, accessor yields array with value removed.', function () {
			// Arrange
			var initialValue = ['A', 'C', 'B', 'E', 'D'],
				subject = new copper.ObservableCollection(initialValue),
				indexToRemove = 3;
				expectedValue = initialValue;
				
			expectedValue.splice(indexToRemove, 1);
				
			// Act
			subject.removeAt(indexToRemove);

			// Assert
			deepEqual(initialValue, expectedValue);
		});

		test('Given subscription, when value removed at index, handler called with removed value and index.', function () {
			// Arrange
			var initialValue = ['A', 'C', 'B', 'E', 'D'],
				subject = new copper.ObservableCollection(initialValue),
				indexToRemove = 4,
				valueToRemove = initialValue[indexToRemove],
				valueRemoved,
				removedIndex;

			subject.subscribe('itemRemoved', function (item, index) {
				valueRemoved = item;
				removedIndex = index;
			});

			// Act
			subject.removeAt(indexToRemove);

			// Assert
			equal(valueRemoved, valueToRemove);
			equal(removedIndex, indexToRemove);
		});
		
		module('SmartEvent');

		test('ctor / Given name / Initializes name property to specified value', function () {
			// Arrange
			var name = 'SecurityBreach',
				subject;

			// Act
			subject = new copper.SmartEvent(name);

			// Assert
			equal(subject.name, name);
		});

		test('ctor / Initializes handlers property to empty', function () {
			// Arrange
			var subject;

			// Act
			subject = new copper.SmartEvent();

			// Assert
			deepEqual(subject.handlers, []);
		});

		test('subscribe / Given function / Adds handler to handlers list', function () {
			// Arrange
			var subject = new copper.SmartEvent(),
				handler = function () { };

			// Act
			subject.subscribe(handler);

			// Assert
			deepEqual(subject.handlers, [handler]);
		});

		test('subscribe / Given function already added / Does not add handler again', function () {
			// Arrange
			var subject = new copper.SmartEvent(),
				handler1 = function () { },
				handler2 = function () { };

			subject.subscribe(handler1);
			subject.subscribe(handler2);

			// Act
			subject.subscribe(handler1);

			// Assert
			deepEqual(subject.handlers, [handler1, handler2]);
		});

		test('subscribe / Given a non-function value / Does nothing', function () {
			// Arrange
			var subject = new copper.SmartEvent();

			// Act
			subject.subscribe({ something: 'not a function' });

			// Assert
			deepEqual(subject.handlers, []);
		});

		test('unsubscribe / Given a function already added / Removes handler', function () {
			// Arrange
			var subject = new copper.SmartEvent(),
				handler1 = function () { },
				handler2 = function () { };

			subject.subscribe(handler1);
			subject.subscribe(handler2);

			// Act
			subject.unsubscribe(handler2);

			// Assert
			deepEqual(subject.handlers, [handler1]);
		});

		test('unsubscribe / Given a function not yet added / Does nothing', function () {
			// Arrange
			var subject = new copper.SmartEvent(),
				handler1 = function () { },
				handler2 = function () { };

			subject.subscribe(handler1);
			
			// Act
			subject.unsubscribe(handler2);

			// Assert
			deepEqual(subject.handlers, [handler1]);
		});

		test('unsubscribe / Given a non-function value / Does nothing', function () {
			// Arrange
			var subject = new copper.SmartEvent(),
				handler = function () { };

			subject.subscribe(handler);

			// Act
			subject.unsubscribe({ something: 'not a function' });

			// Assert
			deepEqual(subject.handlers, [handler]);
		});

		test('raise / Calls each subscribed function', function () {
			// Arrange
			var subject = new copper.SmartEvent(),
				handler1Called = false,
				handler1 = function () { handler1Called = true },
				handler2Called = false,
				handler2 = function () { handler2Called = true },
				handler3Called = false,
				handler3 = function () { handler3Called = true };

			subject.subscribe(handler1);
			subject.subscribe(handler2);
			subject.subscribe(handler3);

			// Act
			subject.raise();

			// Assert
			ok(_([handler1Called, handler2Called, handler3Called]).all(function (item) { return item; }));
		});
		
		module('Bind');

		test('Given a view with no bindModel method / Bind creates one.', function () {
			// Arrange
			var view = {},
				model = { something: 'something' };

			copper.Bind({
				model: {},
				view: view
			});
			
			// Act
			view.bindModel(model);

			// Assert
			equal(view._model, model);
		});
		
		givenModelWithFunctionProperty = function (propertyName, propertyFunction, continueTest) {
			var model = {};
			model[propertyName] = propertyFunction;
			continueTest(model);
		}

		test('Given a model with a function property with name the same ID as an anchor in the HTML / When anchor clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				propertyName = 'helloAnchor',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				copper.Bind({ model: model });

				// Act
				$('#' + propertyName).click();
			});

			// Assert
			ok(called);
		});
		
		test('Given a model with a function property /  Given a view selector hash entry with name of function property and matching an anchor in the HTML / When anchor clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				propertyName = 'overreaction',
				id = 'helloAnchor',
				propertyFunction = function () { called = true; },
				selectors = {};
				
			selectors[propertyName] = '#' + id;

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				copper.Bind({
					model: model,
					view: {
						selectorFor: selectors
					}
				});

				// Act
				$('#' + id).click();
			});

			// Assert
			ok(called);
		});

		test('Given a model with a function property with name the same ID as a button in the HTML / When button clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				propertyName = 'helloButton',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				copper.Bind({ model: model });

				// Act
				$('#' + propertyName).click();
			});

			// Assert
			ok(called);
		});

		test('Given a model with a function property with name the same ID as a submit input in the HTML / When submit input clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				propertyName = 'helloInputSubmit',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				copper.Bind({ model: model });

				// Act
				$('#' + propertyName).click();
			});

			// Assert
			ok(called);
		});

		test('Given a model with a function property with name the same ID as a button input in the HTML / When button input clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				propertyName = 'helloInputButton',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				copper.Bind({ model: model });

				// Act
				$('#' + propertyName).click();
			});

			// Assert
			ok(called);
		});

		test('Given a model with a function property with name the same ID as a reset input in the HTML / When reset input clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				propertyName = 'helloInputReset',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				copper.Bind({ model: model });

				// Act
				$('#' + propertyName).click();
			});

			// Assert
			ok(called);
		});

		test('Given a model with a function property with name "Clicked" and a view with a clickable scope element / When element clicked / Calls the function ', function () {
			// Arrange
			var called = false,
				docScope = $('#helloAnchor'),
				propertyName = 'Click',
				propertyFunction = function () { called = true; };

			givenModelWithFunctionProperty(propertyName, propertyFunction, function (model) {
				copper.Bind({
					view: {
						$documentScope: docScope
					},
					model: model });

				// Act
				docScope.click();
			});

			// Assert
			ok(called);
		});

		test('Given a model with a function property with name not found in HTML / Constructor does not throw', function () {
			expect(1);

			// Arrange
			var propertyName = 'iDoNotExist';

			givenModelWithFunctionProperty(propertyName, function () { }, function (model) {
				copper.Bind({ model: model });

				// Assert
				ok(true);
			});
		});

		var givenModelWithObservableProperty = function (propertyName, initialValue, continueTest) {
			var model = {};
			model[propertyName] = new copper.Observable(initialValue);
			continueTest(model);
		};

		var givenTagWithIdContainsText = function (id, content, continueTest) {
			$('#' + id).html(content);
			continueTest();
		};

		var givenInputWithIdHasValue = function (id, value, continueTest) {
			$('#' + id).val(value);
			continueTest();
		};
		
		var givenInputWithNameHasValue = function (id, value, continueTest) {
			var selector = 'input[name="' + id + '"]';
			$(selector).val(value);
			continueTest(selector);
		};

		test('Given a model with an Observable property with name the same ID as an element in the HTML / When observable changes / HTML element content is changed to match observable value', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'dynamicContent',
				initialValue = 'blah',
				oldContent = 'Something unremarkable',
				newContent = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenTagWithIdContainsText(propertyName, oldContent, function () {
					copper.Bind({ model: model });

					// Act
					model[propertyName].val(newContent);

					// Assert
					equal($('#' + propertyName).html(), newContent);
				});
			});
		});
		
		test('Given a model with an Observable property / Given a view selector hash entry with name of Observable property and value of an HTML element / When observable changes / Content of HTML element selected by hashed selector is changed to match observable value', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'some awesome property',
				id = 'dynamicContent',
				initialValue = 'blah',
				oldContent = 'Something unremarkable',
				newContent = 'Something super special and important.',
				selectors = {};
			
			selectors[propertyName] = '#' + id;

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenTagWithIdContainsText(id, oldContent, function () {
					copper.Bind({
						model: model,
						view: {
							selectorFor: selectors
						}
					});

					// Act
					model[propertyName].val(newContent);

					// Assert
					equal($('#' + id).html(), newContent);
				});
			});
		});
		
		test('Given a model with an Observable property / Given a view selector hash entry with name of Observable property and value of input in the HTML / When input changes / Observable value is changed to match value of input', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'something crazy',
				id = 'dynamicInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.',
				selectors = {};
			
			selectors[propertyName] = '#' + id;

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(id, oldValue, function () {
					copper.Bind({
						model: model,
						view: {
							selectorFor: selectors
						}
					});
					
					
					$('#' + id).val(newValue);

					// Act
					$('#' + id).trigger('change');

					// Assert
					equal(model[propertyName].val(), newValue);
				});
			});
		});

		test('Given a model with an Observable property with name the same ID as an input in the HTML / When input changes / Observable value is changed to match value of input', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'dynamicInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(propertyName, oldValue, function () {
					copper.Bind({ model: model });
					$('#' + propertyName).val(newValue);

					// Act
					$('#' + propertyName).trigger('change');

					// Assert
					equal(model[propertyName].val(), newValue);
				});
			});
		});
		
		test('Given a model with an Observable property with name the same ID as an input in the HTML / When obseravble changes / Input value is changed to match observable value', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'dynamicInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(propertyName, oldValue, function () {
					copper.Bind({ model: model });
					
					// Act
					model[propertyName].val(newValue);

					// Assert
					equal($('#' + propertyName).val(), newValue);
				});
			});
		});
		
		test('Given a model with an Observable property with name the same as an input name in the HTML / When input changes / Observable value is changed to match value of input', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'namedInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithNameHasValue(propertyName, oldValue, function (selector) {
					copper.Bind({ model: model });
					$(selector).val(newValue);

					// Act
					$(selector).trigger('change');

					// Assert
					equal(model[propertyName].val(), newValue);
				});
			});
		});
		
		test('Given a model with an Observable property with name the same as an input name in the HTML / When observable changes / Input value is changed to match observable value', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'namedInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithNameHasValue(propertyName, oldValue, function (selector) {
					copper.Bind({ model: model });
					
					// Act
					model[propertyName].val(newValue);

					// Assert
					equal($(selector).val(), newValue);
				});
			});
		});
		
		test('Given a model with an Observable property named "Value" and a view with an editable scope element / When observable changes / HTML element content is changed to match observable value', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'Value',
				elementId = 'dynamicInput',
				$docScope = $('#' + elementId),
				initialValue = 'blah',
				oldContent = 'Something unremarkable',
				newContent = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenTagWithIdContainsText(elementId, oldContent, function () {
					copper.Bind({
						view: {
							$documentScope: $docScope
						},
						model: model
					});

					// Act
					model[propertyName].val(newContent);

					// Assert
					equal($docScope.val(), newContent);
				});
			});
		});
		
		test('Given a model with an Observable property named "Is_X" and a view with a classless scope element / When observable becomes true / HTML element receives a class of X', function () {
			expect(1);

			// Arrange
			var called = false,
				mode = 'changed',
				propertyName = 'Is_' + mode,
				elementId = 'modalElement',
				$docScope = $('#' + elementId),
				initialValue = false;

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				copper.Bind({
					view: {
						$documentScope: $docScope
					},
					model: model
				});

				// Act
				model[propertyName].val(true);

				// Assert
				ok($docScope.hasClass(mode));
			});
		});
		
		test('Given a model with an Observable property named "Is_X" and a view with a classed scope element / When observable becomes false / HTML element loses class of X', function () {
			expect(1);

			// Arrange
			var called = false,
				mode = 'changed',
				propertyName = 'Is_' + mode,
				elementId = 'modalElement',
				$docScope = $('#' + elementId),
				initialValue = true;

			givenElementWithClass($docScope, mode, function() {
				givenModelWithObservableProperty(propertyName, initialValue, function (model) {
					copper.Bind({
						view: {
							$documentScope: $docScope
						},
						model: model
					});

					// Act
					model[propertyName].val(false);

					// Assert
					ok(!$docScope.hasClass(mode));
				});
			});
		});
		
		var givenElementWithClass = function ($element, extraClass, continueTest) {
			if (!$element.hasClass(extraClass)) {
				$element.addClass(extraClass);
			}
			
			continueTest();
		};

		test('Given a model with an Observable property named "Is_X" and a view with a multi-classed scope element / When observable becomes false / HTML element does not lose non-X classes', function () {
			expect(1);

			// Arrange
			var called = false,
				mode = 'changed',
				propertyName = 'Is_' + mode,
				elementId = 'modalElement',
				$docScope = $('#' + elementId),
				initialValue = true,
				extraClass = 'something';
				
			givenElementWithClass($docScope, extraClass, function() {
				givenModelWithObservableProperty(propertyName, initialValue, function (model) {
					copper.Bind({
						view: {
							$documentScope: $docScope
						},
						model: model
					});

					// Act
					model[propertyName].val(false);

					// Assert
					ok($docScope.hasClass(extraClass));
				});
			});
		});
		
		test('Given a model with an Observable property named "Value" and a view with an editable scope element / When input changes / Observable value is changed to match value of input', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'Value',
				elementId = 'dynamicInput',
				$docScope = $('#' + elementId),
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(elementId, oldValue, function () {
					copper.Bind({
						view: {
							$documentScope: $docScope
						},
						model: model
					});
					$docScope.val(newValue);

					// Act
					$docScope.trigger('change');

					// Assert
					equal(model[propertyName].val(), newValue);
				});
			});
		});

		test('Given a model with an Observable property with name not found in HTML or selector hash / Constructor does not throw', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'iDoNotExist',
				initialValue = 'blah',
				newContent = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				copper.Bind({ model: model });

				// Act
				model[propertyName].val(newContent);

				// Assert
				ok(true);
			});
		});

		// Test HTML scoping.
		test('Given a model with an Observable property with name the same ID as an input outside the scope / When input changes / Observable value does not change', function () {
			expect(1);

			// Arrange
			var called = false,
				propertyName = 'dynamicInput',
				initialValue = 'blah',
				oldValue = 'Something unremarkable',
				newValue = 'Something super special and important.';

			givenModelWithObservableProperty(propertyName, initialValue, function (model) {
				givenInputWithIdHasValue(propertyName, oldValue, function () {
					copper.Bind({
						model: model,
						view: {
							$documentScope: $('#subView')
						}
					});

					$('#' + propertyName).val(newValue);

					// Act
					$('#' + propertyName).trigger('change');

					// Assert
					equal(model[propertyName].val(), initialValue);
				});
			});
		});

		test('Given a view with a method with a name of X_ViewChanged / Given an input with ID of X in the HTML / Changing the input calls the property from the extension source.', function () {
			// Arrange
			var called = false,
				extendSource,
				subject,
				propertyName = 'dynamicInput';

			view = {};
			view[propertyName + '_ViewChanged'] = function () { called = true; };

			copper.Bind({
				model: {},
				view: view
			});

			// Act
			$('#' + propertyName).trigger('change');

			// Assert
			ok(called);
		});

		test('Given a view with a method with a name of X_Clicked / Given a button with ID of X in the HTML / Clicking the button calls the property from the extension source.', function () {
			// Arrange
			var called = false,
				extendSource,
				subject,
				propertyName = 'helloInputButton';

			view = {};
			view[propertyName + '_Clicked'] = function () { called = true; };

			copper.Bind({
				model: {},
				view: view
			});

			// Act
			$('#' + propertyName).trigger('click');

			// Assert
			ok(called);
		});
	</script>
</html>